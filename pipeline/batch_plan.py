"""Batch migration plan: YAML schema, validation, and cost estimation.

This module defines the batch migration plan format that ties together:
  - VM selection (by name, pattern, folder, tag, regex)
  - Target type mapping (auto or manual override)
  - Execution strategy (waves, priorities, parallelism)
  - Post-migration actions (tag source, power off, cleanup)

The plan is the central artifact: generated by `inventory --auto-map`,
reviewed by the operator, executed by `batch run`.

Usage:
    # Generate from inventory
    vmware2scw inventory --auto-map --output plan.yaml

    # Review & edit plan.yaml

    # Estimate
    vmware2scw batch estimate --plan plan.yaml

    # Execute
    vmware2scw batch run --plan plan.yaml --config migration.yaml
"""

from __future__ import annotations

import fnmatch
import re
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Optional

import yaml
from pydantic import BaseModel, Field, field_validator, model_validator


# ═══════════════════════════════════════════════════════════════════
#  Enums
# ═══════════════════════════════════════════════════════════════════

class SizingStrategy(str, Enum):
    """How to choose the target instance type."""
    EXACT = "exact"            # Match source CPU/RAM as closely as possible
    OPTIMIZE = "optimize"      # Right-size based on actual usage (if tools report it)
    COST_OPTIMIZE = "cost"     # Smallest viable type


class WavePauseMode(str, Enum):
    """What to do after a wave completes."""
    CONTINUE = "continue"       # Proceed to next wave automatically
    PAUSE = "pause"             # Wait for manual confirmation
    PAUSE_ON_FAILURE = "pause_on_failure"  # Pause only if any VM in wave failed


class PostMigrationAction(str, Enum):
    TAG = "tag"
    POWER_OFF = "power_off"
    SNAPSHOT_DELETE = "snapshot_delete"


# ═══════════════════════════════════════════════════════════════════
#  Plan Components
# ═══════════════════════════════════════════════════════════════════

class VMEntry(BaseModel):
    """A single VM or VM pattern in the migration plan."""

    # Selection — one of these must be set
    vm_name: Optional[str] = Field(None, description="Exact VM name")
    vm_pattern: Optional[str] = Field(None, description="Glob pattern (e.g. 'web-*')")
    vm_regex: Optional[str] = Field(None, description="Regex pattern for VM names")
    vm_folder: Optional[str] = Field(None, description="vCenter folder path")
    vm_tag: Optional[str] = Field(None, description="vCenter tag")

    # Target configuration
    target_type: Optional[str] = Field(None, description="Scaleway instance type override")
    zone: Optional[str] = Field(None, description="Target zone override")
    sizing_strategy: Optional[SizingStrategy] = Field(None, description="Sizing strategy override")

    # Execution
    priority: int = Field(5, ge=1, le=10, description="Priority (1=highest, 10=lowest)")
    wave: Optional[str] = Field(None, description="Wave name (for staged rollout)")
    skip_validation: bool = Field(False, description="Skip pre-migration validation")

    # Metadata
    tags: list[str] = Field(default_factory=list, description="Tags for the Scaleway instance")
    network_mapping: dict[str, str] = Field(default_factory=dict, description="VMware network → SCW VPC")
    notes: str = Field("", description="Operator notes")

    @model_validator(mode="after")
    def check_selector(self) -> "VMEntry":
        selectors = [self.vm_name, self.vm_pattern, self.vm_regex, self.vm_folder, self.vm_tag]
        if not any(selectors):
            raise ValueError("At least one of vm_name, vm_pattern, vm_regex, vm_folder, vm_tag must be set")
        return self

    def matches(self, vm_name: str, vm_folder: str = "", vm_tags: list[str] | None = None) -> bool:
        """Check if a VM matches this entry's selector."""
        if self.vm_name:
            return vm_name == self.vm_name
        if self.vm_pattern:
            return fnmatch.fnmatch(vm_name, self.vm_pattern)
        if self.vm_regex:
            return bool(re.match(self.vm_regex, vm_name))
        if self.vm_folder:
            return vm_folder.startswith(self.vm_folder)
        if self.vm_tag and vm_tags:
            return self.vm_tag in vm_tags
        return False


class ExcludeEntry(BaseModel):
    """VM exclusion rule."""
    vm_name: Optional[str] = None
    vm_pattern: Optional[str] = None
    vm_regex: Optional[str] = None

    def matches(self, vm_name: str) -> bool:
        if self.vm_name:
            return vm_name == self.vm_name
        if self.vm_pattern:
            return fnmatch.fnmatch(vm_name, self.vm_pattern)
        if self.vm_regex:
            return bool(re.match(self.vm_regex, vm_name))
        return False


class WaveConfig(BaseModel):
    """Configuration for a migration wave."""
    name: str
    vms: list[str] = Field(default_factory=list, description="VM names or patterns")
    pause_after: WavePauseMode = WavePauseMode.PAUSE_ON_FAILURE
    max_parallel: Optional[int] = Field(None, description="Override parallel limit for this wave")


class PostMigrationConfig(BaseModel):
    """Actions to perform after successful migration."""
    tag_source: Optional[str] = Field(None, description="Tag to add to source VM in vCenter")
    power_off_source: bool = Field(False, description="Power off source VM after migration")
    delete_vmware_snapshot: bool = Field(True, description="Delete migration snapshot")
    delete_s3_transit: bool = Field(True, description="Delete S3 transit files")


class ConcurrencyConfig(BaseModel):
    """Concurrency limits for the batch orchestrator."""
    max_exports_per_host: int = Field(4, ge=1, le=8, description="NFC lease limit per ESXi host")
    max_concurrent_conversions: int = Field(3, ge=1, le=10, description="Parallel disk conversions (I/O bound)")
    max_concurrent_uploads: int = Field(6, ge=1, le=20, description="Parallel S3 uploads")
    max_concurrent_imports: int = Field(5, ge=1, le=20, description="Parallel Scaleway API imports")
    max_total_workers: int = Field(10, ge=1, le=50, description="Global concurrency limit")


class DefaultsConfig(BaseModel):
    """Default values applied to all VM entries unless overridden."""
    zone: str = Field("fr-par-1", description="Default Scaleway zone")
    sizing_strategy: SizingStrategy = Field(SizingStrategy.OPTIMIZE)
    tags: list[str] = Field(default_factory=list)
    network_mapping: dict[str, str] = Field(default_factory=dict)
    skip_validation: bool = False


# ═══════════════════════════════════════════════════════════════════
#  Main Plan Model
# ═══════════════════════════════════════════════════════════════════

class BatchPlan(BaseModel):
    """Complete batch migration plan.

    This is the top-level model that represents a migration plan YAML file.
    It is the central artifact for batch migrations:
      1. Generated by `vmware2scw inventory --auto-map --output plan.yaml`
      2. Reviewed and edited by the operator
      3. Estimated with `vmware2scw batch estimate --plan plan.yaml`
      4. Executed with `vmware2scw batch run --plan plan.yaml`
    """

    version: int = Field(1, description="Plan format version")

    metadata: dict[str, Any] = Field(default_factory=dict, description="Plan metadata (auto-generated)")

    defaults: DefaultsConfig = Field(default_factory=DefaultsConfig)

    concurrency: ConcurrencyConfig = Field(default_factory=ConcurrencyConfig)

    migrations: list[VMEntry] = Field(..., min_length=1, description="VMs to migrate")

    exclude: list[ExcludeEntry] = Field(default_factory=list, description="VMs to exclude")

    waves: list[WaveConfig] = Field(default_factory=list, description="Migration waves for staged rollout")

    post_migration: PostMigrationConfig = Field(default_factory=PostMigrationConfig)

    @classmethod
    def from_yaml(cls, path: str | Path) -> "BatchPlan":
        """Load a batch plan from YAML file."""
        with open(path) as f:
            data = yaml.safe_load(f)
        return cls(**data)

    def to_yaml(self, path: str | Path) -> None:
        """Save batch plan to YAML file."""
        data = self.model_dump(mode="json", exclude_none=True, exclude_defaults=False)
        # Clean up empty collections
        for key in list(data.keys()):
            if isinstance(data[key], (list, dict)) and not data[key] and key not in ("migrations",):
                del data[key]

        with open(path, "w") as f:
            yaml.dump(data, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

    def resolve_vms(self, all_vms: list[dict]) -> list[ResolvedVM]:
        """Resolve VM entries against actual inventory.

        Takes the list of all VMs from vCenter inventory and matches them
        against the plan's migration entries and exclusion rules.

        Args:
            all_vms: List of dicts with at least 'name', optionally 'folder', 'tags'

        Returns:
            List of ResolvedVM with entry config applied
        """
        resolved = []
        seen_names: set[str] = set()

        for vm_data in all_vms:
            vm_name = vm_data["name"]

            # Check exclusions first
            if any(ex.matches(vm_name) for ex in self.exclude):
                continue

            # Find matching entry
            for entry in self.migrations:
                if entry.matches(
                    vm_name,
                    vm_folder=vm_data.get("folder", ""),
                    vm_tags=vm_data.get("tags"),
                ):
                    if vm_name in seen_names:
                        continue  # First match wins
                    seen_names.add(vm_name)

                    resolved.append(ResolvedVM(
                        vm_name=vm_name,
                        target_type=entry.target_type,
                        zone=entry.zone or self.defaults.zone,
                        sizing_strategy=entry.sizing_strategy or self.defaults.sizing_strategy,
                        priority=entry.priority,
                        wave=entry.wave,
                        skip_validation=entry.skip_validation or self.defaults.skip_validation,
                        tags=entry.tags or self.defaults.tags,
                        network_mapping=entry.network_mapping or self.defaults.network_mapping,
                        notes=entry.notes,
                        vm_info=vm_data,
                    ))

        # Sort by priority
        resolved.sort(key=lambda r: r.priority)
        return resolved

    def get_waves(self, resolved_vms: list["ResolvedVM"]) -> list[list["ResolvedVM"]]:
        """Group resolved VMs into execution waves.

        If waves are defined in the plan, use them.
        Otherwise, group by priority level.
        """
        if self.waves:
            wave_groups = []
            assigned = set()
            for wave_cfg in self.waves:
                wave_vms = []
                for rvm in resolved_vms:
                    if rvm.vm_name in assigned:
                        continue
                    if rvm.wave == wave_cfg.name:
                        wave_vms.append(rvm)
                        assigned.add(rvm.vm_name)
                        continue
                    for pattern in wave_cfg.vms:
                        if fnmatch.fnmatch(rvm.vm_name, pattern) or rvm.vm_name == pattern:
                            wave_vms.append(rvm)
                            assigned.add(rvm.vm_name)
                            break
                if wave_vms:
                    wave_groups.append(wave_vms)

            # Remaining VMs go into a final wave
            remaining = [rvm for rvm in resolved_vms if rvm.vm_name not in assigned]
            if remaining:
                wave_groups.append(remaining)
            return wave_groups

        # No waves defined → group by priority
        priority_groups: dict[int, list[ResolvedVM]] = {}
        for rvm in resolved_vms:
            priority_groups.setdefault(rvm.priority, []).append(rvm)

        return [priority_groups[p] for p in sorted(priority_groups.keys())]


class ResolvedVM(BaseModel):
    """A VM with all configuration resolved and ready for migration."""
    vm_name: str
    target_type: Optional[str] = None  # None = auto-map
    zone: str = "fr-par-1"
    sizing_strategy: SizingStrategy = SizingStrategy.OPTIMIZE
    priority: int = 5
    wave: Optional[str] = None
    skip_validation: bool = False
    tags: list[str] = Field(default_factory=list)
    network_mapping: dict[str, str] = Field(default_factory=dict)
    notes: str = ""
    vm_info: dict = Field(default_factory=dict, description="Raw VM info from inventory")


# ═══════════════════════════════════════════════════════════════════
#  Pre-flight Estimation
# ═══════════════════════════════════════════════════════════════════

class MigrationEstimate(BaseModel):
    """Pre-flight estimate for a batch migration."""
    total_vms: int = 0
    linux_vms: int = 0
    windows_vms: int = 0
    total_disk_gb: float = 0.0
    required_work_space_gb: float = 0.0  # ~2x total disk for conversion
    estimated_duration_minutes: float = 0.0
    estimated_cost_eur: float = 0.0      # Scaleway monthly cost of target types
    warnings: list[str] = Field(default_factory=list)
    per_vm: list[dict] = Field(default_factory=list)

    def summary_text(self) -> str:
        """Human-readable summary."""
        lines = [
            f"═══ Migration Estimate ═══",
            f"  VMs:           {self.total_vms} ({self.linux_vms} Linux, {self.windows_vms} Windows)",
            f"  Total disk:    {self.total_disk_gb:.0f} GB",
            f"  Work space:    {self.required_work_space_gb:.0f} GB needed (2× disk for conversion)",
            f"  Est. duration: {self.estimated_duration_minutes:.0f} min",
            f"  Est. monthly:  €{self.estimated_cost_eur:.2f}/month (Scaleway target types)",
        ]
        if self.warnings:
            lines.append(f"  ⚠ Warnings:")
            for w in self.warnings:
                lines.append(f"    - {w}")
        return "\n".join(lines)
